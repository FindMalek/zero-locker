---
globs: hooks/use-dialog-state.ts,**/use-dialog-state.ts
description: Dialog state management patterns and best practices
---

# Dialog State Management Hook

The [use-dialog-state.ts](mdc:hooks/use-dialog-state.ts) hook provides clean, type-safe dialog state management using useReducer patterns instead of multiple useState hooks.

## Hook Overview

### Single Dialog Management
```tsx
export function useDialogState<T = Record<string, unknown>>(initialState?: T) {
  const [state, dispatch] = useReducer(dialogReducer<T>, {
    open: false,
    data: initialState || null,
  })

  const openDialog = (data: T) => {
    dispatch({ type: 'OPEN', payload: data })
  }

  const closeDialog = () => {
    dispatch({ type: 'CLOSE' })
  }

  return {
    isOpen: state.open,
    data: state.data,
    openDialog,
    closeDialog,
  }
}
```

### Multiple Dialogs Management
```tsx
export function useMultiDialogState() {
  const [state, dispatch] = useReducer(multiDialogReducer, initialMultiDialogState)

  return {
    moveDialog: { isOpen, data, open, close },
    deleteDialog: { isOpen, data, open, close }
  }
}
```

## Usage Patterns

### Single Dialog Example
```tsx
function MyComponent() {
  const dialog = useDialogState<{ id: string; name: string }>()
  
  const handleOpen = (item: { id: string; name: string }) => {
    dialog.openDialog(item)
  }
  
  return (
    <>
      <Button onClick={() => handleOpen({ id: '1', name: 'Test' })}>
        Open Dialog
      </Button>
      
      {dialog.data && (
        <Dialog open={dialog.isOpen} onOpenChange={(open) => {
          if (!open) dialog.closeDialog()
        }}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>{dialog.data.name}</DialogTitle>
            </DialogHeader>
          </DialogContent>
        </Dialog>
      )}
    </>
  )
}
```

### Multiple Dialogs Example
```tsx
function CredentialCardsView() {
  const dialogs = useMultiDialogState()
  
  const handleMove = (id: string, identifier: string, containerId?: string) => {
    dialogs.moveDialog.open({ id, identifier, containerId })
  }
  
  const handleDelete = (id: string, identifier: string) => {
    dialogs.deleteDialog.open({ id, identifier })
  }
  
  return (
    <>
      {/* Component content */}
      
      {dialogs.deleteDialog.data && (
        <DeleteDialog
          open={dialogs.deleteDialog.isOpen}
          onOpenChange={(open) => {
            if (!open) dialogs.deleteDialog.close()
          }}
          credentialId={dialogs.deleteDialog.data.id}
          credentialIdentifier={dialogs.deleteDialog.data.identifier}
        />
      )}
      
      {dialogs.moveDialog.data && (
        <MoveDialog
          open={dialogs.moveDialog.isOpen}
          onOpenChange={(open) => {
            if (!open) dialogs.moveDialog.close()
          }}
          credentialId={dialogs.moveDialog.data.id}
          credentialIdentifier={dialogs.moveDialog.data.identifier}
          currentContainerId={dialogs.moveDialog.data.containerId}
        />
      )}
    </>
  )
}
```

## Anti-Patterns to Avoid

### ❌ Multiple useState Anti-Pattern
```tsx
// Don't do this - multiple useState hooks for related state
const [moveDialogOpen, setMoveDialogOpen] = useState(false)
const [deleteDialogOpen, setDeleteDialogOpen] = useState(false)
const [credentialToDelete, setCredentialToDelete] = useState<{...} | null>(null)
const [credentialToMove, setCredentialToMove] = useState<{...} | null>(null)

const handleMove = (id, identifier, containerId) => {
  setCredentialToMove({ id, identifier, containerId })
  setMoveDialogOpen(true)
}
```

### ✅ Clean useReducer Pattern
```tsx
// Do this - single hook managing all dialog state
const dialogs = useMultiDialogState()

const handleMove = (id, identifier, containerId) => {
  dialogs.moveDialog.open({ id, identifier, containerId })
}
```

## Benefits

1. **Reduced Complexity**: Multiple useState → Single custom hook
2. **Type Safety**: Full TypeScript support with generics
3. **Reusability**: Hook can be used across components
4. **Maintainability**: Single source of truth for dialog state
5. **Predictable State**: useReducer ensures consistent state updates
6. **Clean API**: Simple `open()` and `close()` methods

## State Management Patterns

### Dialog State Structure
```tsx
type DialogState<T = Record<string, unknown>> = {
  open: boolean
  data: T | null
}

type DialogAction<T = Record<string, unknown>> =
  | { type: 'OPEN'; payload: T }
  | { type: 'CLOSE' }
```

### Multi-Dialog State Structure
```tsx
type MultiDialogState = {
  moveDialog: DialogState<{
    id: string
    identifier: string
    containerId?: string | null
  }>
  deleteDialog: DialogState<{
    id: string
    identifier: string
  }>
}
```

## Best Practices

1. **Use TypeScript Generics**: Provide type safety for dialog data
2. **Consistent Naming**: Use descriptive action types and payloads
3. **Immutable Updates**: Always return new state objects
4. **Error Handling**: Handle edge cases in reducer logic
5. **Testing**: Test reducer logic independently
6. **Documentation**: Document complex dialog state requirements

## Integration with Components

### Dialog Component Integration
```tsx
// Always check for data existence before rendering
{dialog.data && (
  <Dialog 
    open={dialog.isOpen} 
    onOpenChange={(open) => {
      if (!open) dialog.closeDialog()
    }}
  >
    {/* Dialog content using dialog.data */}
  </Dialog>
)}
```

### Event Handler Integration
```tsx
// Clean event handlers
const handleAction = (item: ItemType) => {
  dialog.openDialog(item)
}

// In JSX
<Button onClick={() => handleAction(item)}>
  Action
</Button>
```

## Performance Considerations

1. **Memoization**: Dialog state changes trigger re-renders
2. **Conditional Rendering**: Only render dialogs when data exists
3. **Event Handlers**: Use useCallback for stable references
4. **State Updates**: Batch related state updates when possible

## Testing Strategies

### Unit Testing
```tsx
describe('useDialogState', () => {
  it('should open dialog with data', () => {
    const { result } = renderHook(() => useDialogState())
    
    act(() => {
      result.current.openDialog({ id: '1', name: 'Test' })
    })
    
    expect(result.current.isOpen).toBe(true)
    expect(result.current.data).toEqual({ id: '1', name: 'Test' })
  })
})
```

### Integration Testing
```tsx
describe('Dialog Integration', () => {
  it('should open and close dialog correctly', () => {
    render(<MyComponent />)
    
    fireEvent.click(screen.getByText('Open Dialog'))
    expect(screen.getByRole('dialog')).toBeInTheDocument()
    
    fireEvent.click(screen.getByText('Close'))
    expect(screen.queryByRole('dialog')).not.toBeInTheDocument()
  })
})
```