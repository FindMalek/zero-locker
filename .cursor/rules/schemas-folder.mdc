---
globs: schemas/**/*
---

# Schemas Folder - Zod Validation Schemas

The `/schemas` folder is the **single source of truth** for all Zod validation schemas in the Zero Locker application. This centralized approach ensures consistent data validation, type safety, and API contracts across the entire codebase.

## Structure Overview

```
schemas/
├── card/              # Card-related schemas
│   ├── enums.ts       # Card enum schemas
│   ├── input.ts       # Card input schemas
│   ├── output.ts      # Card output schemas
│   ├── metadata/      # Card metadata subfolder
│   │   ├── input.ts   # Card metadata input schemas
│   │   ├── output.ts  # Card metadata output schemas
│   │   └── index.ts   # Barrel exports
│   └── index.ts       # Barrel exports
├── credential/        # Credential-related schemas
│   ├── enums.ts       # Credential enum schemas
│   ├── input.ts       # Credential input schemas
│   ├── output.ts      # Credential output schemas
│   ├── history/       # Credential history subfolder
│   │   ├── input.ts   # History input schemas
│   │   ├── output.ts  # History output schemas
│   │   └── index.ts   # Barrel exports
│   ├── key-value/     # Credential key-value pairs subfolder
│   │   ├── input.ts   # Key-value input schemas
│   │   ├── output.ts  # Key-value output schemas
│   │   └── index.ts   # Barrel exports
│   ├── metadata/      # Credential metadata subfolder
│   │   ├── input.ts   # Metadata input schemas
│   │   ├── output.ts  # Metadata output schemas
│   │   └── index.ts   # Barrel exports
│   ├── with-metadata/ # Combined credential + metadata subfolder
│   │   ├── input.ts   # Combined input schemas
│   │   ├── output.ts  # Combined output schemas
│   │   └── index.ts   # Barrel exports
│   └── index.ts       # Barrel exports
├── encryption/        # Encryption schemas
│   ├── input.ts       # Encryption input schemas
│   ├── output.ts      # Encryption output schemas
│   └── index.ts       # Barrel exports
├── secrets/           # Secret-related schemas
│   ├── input.ts       # Secret input schemas
│   ├── output.ts      # Secret output schemas
│   ├── metadata/      # Secret metadata subfolder
│   │   ├── input.ts   # Metadata input schemas
│   │   ├── output.ts  # Metadata output schemas
│   │   └── index.ts   # Barrel exports
│   └── index.ts       # Barrel exports
├── user/              # User-related schemas
│   ├── user/          # User entity subfolder
│   │   ├── input.ts   # User input schemas (includes auth schemas)
│   │   ├── output.ts  # User output schemas
│   │   └── index.ts   # Barrel exports
│   ├── waitlist/      # Waitlist subfolder
│   │   ├── input.ts   # Waitlist input schemas
│   │   ├── output.ts  # Waitlist output schemas
│   │   └── index.ts   # Barrel exports
│   ├── statistics/    # Statistics subfolder
│   │   ├── input.ts   # Statistics input schemas
│   │   ├── output.ts  # Statistics output schemas
│   │   └── index.ts   # Barrel exports
│   ├── roadmap/       # Roadmap subfolder
│   │   ├── input.ts   # Roadmap input schemas
│   │   ├── output.ts  # Roadmap output schemas
│   │   └── index.ts   # Barrel exports
│   └── index.ts       # Barrel exports
├── utils/             # Utility schemas
│   ├── container/     # Container subfolder
│   │   ├── enums.ts   # Container enum schemas
│   │   ├── input.ts   # Container input schemas
│   │   ├── output.ts  # Container output schemas
│   │   ├── with-secrets/ # Container with secrets subfolder
│   │   │   ├── input.ts   # Combined input schemas
│   │   │   ├── output.ts  # Combined output schemas
│   │   │   └── index.ts   # Barrel exports
│   │   └── index.ts   # Barrel exports
│   ├── platform/      # Platform subfolder
│   │   ├── enums.ts   # Platform enum schemas
│   │   ├── input.ts   # Platform input schemas
│   │   ├── output.ts  # Platform output schemas
│   │   └── index.ts   # Barrel exports
│   ├── tag/           # Tag subfolder
│   │   ├── input.ts   # Tag input schemas
│   │   ├── output.ts  # Tag output schemas
│   │   └── index.ts   # Barrel exports
│   ├── base-key-value-pair.ts # Base key-value schema
│   ├── breadcrumb.ts  # Breadcrumb navigation schemas
│   ├── utils.ts       # Utility types and schemas (includes environment validation)
│   └── index.ts       # Barrel exports
└── index.ts           # Main barrel exports (namespace exports)
```

## Schema Categories

### 1. Entity Schemas

Define the structure of database entities and their transformations:

```tsx
// output.ts
export const credentialSimpleOutputSchema = z.object({
  id: z.string(),
  identifier: z.string(),
  description: z.string().nullable(),
  status: z.nativeEnum(AccountStatus),
  lastViewed: z.date().nullable(),
  createdAt: z.date(),
  updatedAt: z.date(),
  platformId: z.string(),
  userId: z.string(),
  containerId: z.string().nullable(),
  passwordEncryptionId: z.string(),
})

export type CredentialSimpleOutput = z.infer<
  typeof credentialSimpleOutputSchema
>
```

### 2. Input Schemas (Data Transfer Objects)

Data Transfer Objects for API input validation and form handling:

```tsx
// input.ts
export const credentialInputSchema = z.object({
  identifier: z.string().min(1, "Username/identifier is required"),
  description: z.string().optional(),
  status: z.nativeEnum(AccountStatus),
  platformId: z.string().min(1, "Platform is required"),
  containerId: z.string().optional(),
})

export type CredentialInput = z.infer<typeof credentialInputSchema>

// Authentication schemas (in user/user/input.ts)
export const loginInputSchema = z.object({
  email: z.string().email("Please enter a valid email address"),
  password: z.string().min(8, "Password must be at least 8 characters"),
  rememberMe: z.boolean(),
})

export const signUpInputSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Please enter a valid email address"),
  password: z.string().min(8, "Password must be at least 8 characters"),
  image: z.string().url("Please enter a valid image URL").optional(),
})

// CRUD Operation Input Schemas
export const createCredentialInputSchema = credentialInputSchema.extend({
  passwordEncryption: encryptedDataInputSchema,
  tags: z.array(tagInputSchema).optional(),
})

export const updateCredentialInputSchema = credentialInputSchema
  .partial()
  .extend({
    id: z.string().min(1, "Credential ID is required"),
    passwordEncryption: encryptedDataInputSchema.optional(),
  })

export const listCredentialsInputSchema = z.object({
  page: z.number().int().min(1).default(1),
  limit: z.number().int().min(1).max(100).default(10),
  search: z.string().optional(),
  containerId: z.string().optional(),
  platformId: z.string().optional(),
  status: z.nativeEnum(AccountStatus).optional(),
  filters: z.any().optional(),
  sort: z.any().optional(),
})
```

### 3. Output Schemas (Return Objects)

Return Objects for API responses and client-safe data:

```tsx
// output.ts
export const credentialSimpleOutputSchema = z.object({
  id: z.string(),
  identifier: z.string(),
  description: z.string().nullable(),
  status: z.nativeEnum(AccountStatus),
  lastViewed: z.date().nullable(),
  createdAt: z.date(),
  updatedAt: z.date(),
  platformId: z.string(),
  userId: z.string(),
  containerId: z.string().nullable(),
  passwordEncryptionId: z.string(),
})

export const credentialIncludeOutputSchema =
  credentialSimpleOutputSchema.extend({
    tags: z.array(tagSimpleOutputSchema),
    platform: platformSimpleOutputSchema,
    container: containerSimpleOutputSchema.nullable(),
  })

export const listCredentialsOutputSchema = z.object({
  credentials: z.array(credentialIncludeOutputSchema),
  total: z.number().int(),
  hasMore: z.boolean(),
  page: z.number().int(),
  limit: z.number().int(),
})
```

### 4. Enum Schemas

Schemas for enum definitions and type safety:

```tsx
// enums.ts
export const accountStatusSchema = z.enum([
  AccountStatus.ACTIVE,
  AccountStatus.SUSPENDED,
  AccountStatus.DELETED,
  AccountStatus.ARCHIVED,
])

export const accountStatusEnum = accountStatusSchema.enum
export const LIST_ACCOUNT_STATUSES = Object.values(accountStatusEnum)
export type AccountStatusInfer = z.infer<typeof accountStatusSchema>
```

### 5. Utility Schemas

Common utility schemas for shared functionality:

```tsx
// utils/utils.ts
export const ActivityTypeSchema = z.enum(["CREATED", "UPDATED", "COPIED"])
export const ActivityTypeEnum = ActivityTypeSchema.enum
export type ActivityType = z.infer<typeof ActivityTypeSchema>
export const LIST_ACTIVITY_TYPE = Object.values(ActivityTypeEnum)

export const EntityTypeSchema = z.enum(["CREDENTIAL", "CARD", "SECRET"])
export const EntityTypeEnum = EntityTypeSchema.enum
export type EntityType = z.infer<typeof EntityTypeSchema>
export const LIST_ENTITY_TYPE = Object.values(EntityTypeEnum)

// Environment validation schemas
export const environmentServerSchema = z.object({
  DATABASE_URL: z.string().min(1).url(),
  NODE_ENV: z.enum(["development", "production"]),
  BETTER_AUTH_SECRET: z.string().min(10),
  LOGO_DEV_TOKEN: z.string().min(10),
  RESEND_API_KEY: z.string().min(10),
  MARKETING_SUBSCRIPTION_EMAIL: z.string().email(),
})

export const environmentClientSchema = z.object({
  NEXT_PUBLIC_APP_URL: z.string().url(),
  NEXT_PUBLIC_LOGO_DEV_TOKEN: z.string().min(10),
})
```

### 6. Encryption Schemas

Schemas for encrypted data handling:

```tsx
// encryption/input.ts
export const encryptedDataInputSchema = z.object({
  encryptedValue: z.string().min(1, "Encrypted value is required"),
  iv: z.string().min(1, "IV is required"),
  encryptionKey: z.string().min(1, "Encryption key is required"),
})

export type EncryptedDataInput = z.infer<typeof encryptedDataInputSchema>

// encryption/output.ts
export const encryptedDataSimpleOutputSchema = z.object({
  id: z.string(),
  iv: z.string(),
  encryptionKey: z.string(),
  encryptedValue: z.string(),
  createdAt: z.date(),
  updatedAt: z.date(),
})

export type EncryptedDataSimpleOutput = z.infer<
  typeof encryptedDataSimpleOutputSchema
>
```

## Naming Conventions

### Schema Names

- **Input Schemas**: `{entity}{Type}InputSchema` (e.g., `credentialInputSchema`, `cardMetadataInputSchema`)
- **Output Schemas**: `{entity}{Type}OutputSchema` (e.g., `credentialSimpleOutputSchema`, `userSimpleOutputSchema`)
- **Enum Schemas**: `{entity}Schema` (e.g., `accountStatusSchema`, `cardTypeSchema`)

### Type Names

- **Input Types**: `{Entity}{Type}Input` (e.g., `CredentialInput`, `CardMetadataInput`)
- **Output Types**: `{Entity}{Type}Output` (e.g., `CredentialSimpleOutput`, `UserSimpleOutput`)
- **Enum Types**: `{Entity}Infer` (e.g., `AccountStatusInfer`, `CardTypeInfer`)

### CRUD Operation Schemas

- **Create**: `create{Entity}InputSchema` (e.g., `createCredentialInputSchema`)
- **Get**: `get{Entity}InputSchema` (e.g., `getCredentialInputSchema`)
- **Update**: `update{Entity}InputSchema` (e.g., `updateCredentialInputSchema`)
- **Delete**: `delete{Entity}InputSchema` (e.g., `deleteCredentialInputSchema`)
- **List**: `list{Entity}InputSchema` (e.g., `listCredentialsInputSchema`)

### Output Schema Types

- **Simple**: `{entity}SimpleOutputSchema` (basic entity data)
- **Include**: `{entity}IncludeOutputSchema` (with related entities)
- **List**: `list{Entity}OutputSchema` (paginated list response)

## Import Patterns

### Concrete File Imports

Schemas must import from specific files to avoid circular dependencies. Never use barrel imports within the schemas folder:

```tsx
// ✅ Correct - Concrete file imports
import { loginInputSchema, signUpInputSchema } from "@/schemas/user/user"
import { waitlistInputSchema } from "@/schemas/user/waitlist"
import { credentialInputSchema } from "@/schemas/credential/input"
import { cardInputSchema } from "@/schemas/card/input"
import { secretInputSchema } from "@/schemas/secrets/input"
import { encryptedDataInputSchema } from "@/schemas/encryption/input"
import { EntityTypeSchema } from "@/schemas/utils/utils"

// Type imports
import type { LoginInput, SignUpInput } from "@/schemas/user/user"
import type { CredentialInput } from "@/schemas/credential/input"
import type { CardInput } from "@/schemas/card/input"
import type { SecretInput } from "@/schemas/secrets/input"
import type { EntityType } from "@/schemas/utils/utils"

// ❌ Avoid - Barrel imports within schemas
import { credential } from "@/schemas/credential"
import { card } from "@/schemas/card"
import { secrets } from "@/schemas/secrets"
import { encryption } from "@/schemas/encryption"
```

### Avoiding Circular Dependencies

To prevent circular import issues, schemas should import from specific files rather than barrel exports when importing from other schema modules:

```tsx
// ✅ Good - Import from specific files
import { tagInputSchema } from "@/schemas/utils/tag/input"
import { credentialSimpleOutputSchema } from "@/schemas/credential/output"

// ❌ Avoid - Importing from barrel exports can cause circular dependencies
import { tagInputSchema } from "@/schemas/utils"
import { credentialSimpleOutputSchema } from "@/schemas/credential"
```

### Cross-Schema Dependencies

When schemas need to reference other schemas, use direct imports:

```tsx
// credential/input.ts
import { encryptedDataInputSchema } from "@/schemas/encryption"
import { tagInputSchema } from "@/schemas/utils/tag/input"

// credential/output.ts
import { tagSimpleOutputSchema } from "@/schemas/utils/tag/output"
```

## Schema Patterns

### Optional and Nullable Fields

```tsx
// Use .optional() for truly optional fields
description: z.string().optional(),

// Use .nullable() for fields that can be null in database
lastViewed: z.date().nullable(),

// Use .nullish() for fields that can be null or undefined
metadata: z.string().nullish(),
```

### Validation Messages

```tsx
// Provide clear validation messages
identifier: z.string().min(1, "Username/identifier is required"),
email: z.string().email("Please enter a valid email address"),
password: z.string().min(8, "Password must be at least 8 characters"),
```

### Array Validation

```tsx
// Validate arrays with specific item schemas
tags: z.array(tagInputSchema),
metadata: z.array(credentialMetadataInputSchema),

// Optional arrays
keyValuePairs: z.array(keyValuePairSchema).optional(),
```

### Nested Object Validation

```tsx
// Nested objects with validation
passwordEncryption: encryptedDataInputSchema,
platform: z.object({
  id: z.string(),
  name: z.string(),
  url: z.string().url().optional(),
}),
```

## Schema Composition

### Extending Schemas

```tsx
// Extend base schemas
export const credentialIncludeOutputSchema =
  credentialSimpleOutputSchema.extend({
    tags: z.array(tagSimpleOutputSchema),
  })

// Partial schemas for updates
export const updateCredentialInputSchema = credentialInputSchema
  .partial()
  .extend({
    id: z.string().min(1, "Credential ID is required"),
  })
```

### Schema Reuse

```tsx
// Reuse common patterns
export const baseKeyValuePairSchema = z.object({
  key: z.string().min(1, "Key is required"),
  value: z.string().min(1, "Value is required"),
})

export const credentialKeyValuePairSchema = baseKeyValuePairSchema.extend({
  credentialId: z.string().min(1, "Credential ID is required"),
})
```

## Type Generation

### Infer Types

```tsx
// Generate TypeScript types from schemas
export type CredentialInput = z.infer<typeof credentialInputSchema>
export type CredentialSimpleOutput = z.infer<
  typeof credentialSimpleOutputSchema
>
export type CreateCredentialInput = z.infer<typeof createCredentialInputSchema>
```

### Export Types

```tsx
// Export both schemas and types
export {
  credentialInputSchema,
  credentialSimpleOutputSchema,
  credentialIncludeOutputSchema,
}

export type { CredentialInput, CredentialSimpleOutput, CredentialIncludeOutput }
```

## Validation Patterns

### Custom Validation

```tsx
// Custom validation functions
const validatePassword = (password: string) => {
  const hasUpperCase = /[A-Z]/.test(password)
  const hasLowerCase = /[a-z]/.test(password)
  const hasNumbers = /\d/.test(password)
  const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password)

  return hasUpperCase && hasLowerCase && hasNumbers && hasSpecialChar
}

export const passwordSchema = z
  .string()
  .min(8, "Password must be at least 8 characters")
  .refine(
    validatePassword,
    "Password must contain uppercase, lowercase, number, and special character"
  )
```

### Conditional Validation

```tsx
// Conditional validation based on other fields
export const credentialSchema = z
  .object({
    has2FA: z.boolean(),
    twoFactorCode: z.string().optional(),
  })
  .refine(
    (data) => {
      if (data.has2FA && !data.twoFactorCode) {
        return false
      }
      return true
    },
    {
      message: "Two-factor code is required when 2FA is enabled",
      path: ["twoFactorCode"],
    }
  )
```

## Best Practices

### 1. Naming Conventions

- **Input Schemas**: `{entity}{Type}InputSchema` for input validation
- **Output Schemas**: `{entity}{Type}OutputSchema` for output validation
- **Enum Schemas**: `{entity}Schema` for enum definitions
- **Types**: `{Entity}{Type}Input`, `{Entity}{Type}Output`, etc.

### 2. Validation Messages

- Provide clear, user-friendly error messages
- Use consistent message formatting
- Include field names in messages

### 3. Schema Organization

- Group related schemas in the same file
- Use barrel exports for clean imports
- Separate input schemas from output schemas
- Avoid circular dependencies by using direct imports

### 4. Type Safety

- Always export TypeScript types
- Use strict TypeScript configuration
- Validate all external data

### 5. Performance

- Use appropriate validation levels
- Avoid complex validation in hot paths
- Cache compiled schemas when possible

### 6. Security

- Validate all input data
- Sanitize user input
- Use appropriate string length limits

## Migration Guide

### From Legacy Configuration Files

The schema architecture has been centralized to use the `/schemas` folder as the single source of truth. All schemas have been migrated from configuration files:

```tsx
// ❌ Old approach (removed)
// config/schema.ts
export const loginSchema = z.object({...})
export const signUpSchema = z.object({...})
export const UserDto = z.object({...})

// ✅ New approach (current)
// schemas/user/user/input.ts
export const loginInputSchema = z.object({...})
export const signUpInputSchema = z.object({...})
export const userInputSchema = z.object({...})
```

### Import Updates

Update imports to use the new schema locations:

```tsx
// ❌ Old imports (removed)
import { loginSchema, signUpSchema } from "@/config/schema"
import { UserDto, UserRo } from "@/config/schema"

// ✅ New imports (current)
import { loginInputSchema, signUpInputSchema } from "@/schemas/user/user"
import { userInputSchema, userSimpleOutputSchema } from "@/schemas/user/user"
import { waitlistInputSchema } from "@/schemas/user/waitlist"
```

### Component Updates

Update React components to use the new schema imports:

```tsx
// ❌ Old component imports
import { loginSchema, type LoginFormData } from "@/config/schema"

// ✅ New component imports
import { loginInputSchema, type LoginInput } from "@/schemas/user/user"

// Update form usage
const form = useForm<LoginInput>({
  resolver: zodResolver(loginInputSchema),
  // ...
})
```

## Current Architecture Benefits

### 1. Single Source of Truth
- **Centralized**: All Zod schemas live in the `/schemas` folder
- **No Duplication**: Eliminates duplicate schema definitions across the codebase
- **Consistency**: Ensures uniform validation patterns across the application

### 2. Type Safety
- **Full TypeScript Coverage**: All schemas properly typed with `z.infer<>`
- **Compile-time Validation**: Catches type mismatches during development
- **IDE Support**: Excellent autocomplete and error detection

### 3. Maintainability
- **Organized Structure**: Clear folder hierarchy based on domain entities
- **Easy Discovery**: Developers can quickly find relevant schemas
- **Scalable**: Easy to add new schemas following established patterns

### 4. Performance
- **Namespace Exports**: Prevents circular dependencies and improves build times
- **Tree Shaking**: Only imports what's needed
- **Optimized Imports**: Direct imports from specific files

### 5. Developer Experience
- **Clear Import Paths**: Intuitive import statements
- **Consistent Naming**: Predictable schema and type names
- **Documentation**: Well-documented patterns and examples

## Testing

### Schema Testing

- Test valid data passes validation
- Test invalid data fails validation
- Test edge cases and boundary conditions
- Test custom validation functions

### Integration Testing

- Test schemas with real API endpoints
- Test form validation with user input
- Test error handling and messages

### Circular Dependency Testing

- Verify build completes successfully
- Test that all imports resolve correctly
- Ensure no runtime circular dependency errors